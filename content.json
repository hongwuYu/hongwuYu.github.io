{"meta":{"title":"yhw's personal blog","subtitle":null,"description":null,"author":"hongwu.yu","url":"https://hongwuYu.github.io","root":"/"},"pages":[{"title":"about","date":"2019-04-16T09:33:13.000Z","updated":"2019-04-16T09:33:13.000Z","comments":true,"path":"about/index.html","permalink":"https://hongwuYu.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-04-16T08:52:14.000Z","updated":"2019-04-16T08:52:49.000Z","comments":true,"path":"categories/index.html","permalink":"https://hongwuYu.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-16T08:47:18.000Z","updated":"2019-04-17T04:56:19.000Z","comments":true,"path":"tags/index.html","permalink":"https://hongwuYu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"计算机组成原理学习笔记","slug":"ComputerComposition-first","date":"2019-08-24T04:54:46.809Z","updated":"2019-08-24T07:22:12.139Z","comments":true,"path":"2019/08/24/ComputerComposition-first/","link":"","permalink":"https://hongwuYu.github.io/2019/08/24/ComputerComposition-first/","excerpt":"","text":"冯诺依曼体系结构 &emsp;可编程可存储型计算机：由存储器，运算器，控制器，输入设备，输出设备组成。 性能 计算机性能一般由两个指标来表示：响应时间 和 吞吐量 响应时间是计算机跑完一段程序所花的时间 吞吐量是指在一定时间内，计算机所能处理的任务量 直观来看，响应时间越短，计算机在一定时间内处理的任务量自然就会增多，也就是吞吐量上去了。所以提高响应时间就能提高吞吐量。此外，多增添几个cpu（即现在的多核计算机）也能提高吞吐量。 计算机的计时单位：CPU时钟 &emsp;&emsp;如果是要衡量cpu性能，响应时间应该就指的是cpu实际执行时间。通常我们执行一个程序，可能会进行io操作，可能会因为线程切换中途暂时不执行该段程序等等其他不占用cpu时间的操作。因此，要想实际的去衡量计算机性能，就必须仅计算程序占用cpu的时间。但是对于有些程序，它可能会限制cpu降频运行。即不同的程序使用cpu的方式不同，可能满载可能降频。因此，我们需要对cpu时间进一步分解： &emsp; &emsp;&emsp;&emsp;&emsp;&emsp;cpu执行时间 = 时钟周期数 * 时钟周期时间","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://hongwuYu.github.io/categories/计算机组成原理/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://hongwuYu.github.io/tags/计算机组成原理/"}]},{"title":"go 类型转换","slug":"go-forth","date":"2019-04-20T05:54:47.000Z","updated":"2019-04-20T06:42:25.000Z","comments":true,"path":"2019/04/20/go-forth/","link":"","permalink":"https://hongwuYu.github.io/2019/04/20/go-forth/","excerpt":"","text":"go 命名类型与未命名类型 命名类型 go语言提供type关键字来自定义命名类型 1234567type Int inttype Person struct&#123; name string age int&#125;//Int Person 皆是自定义的命名类型 除了自定义命名类型，go语言的20个预声明简单类型（in† float等）皆是命名类型 未命名类型 go语言基本类型中的复合类型：数组，切片，字典，通道，接口等等皆属于未命名类型 底层类型 预声明类型和未命名类型的底层类型是其本身，而自定义类型的底层类型会逐层向下查找，直到查到的类型是预声明类型或是未命名类型为止 1234567891011//T1,T2的底层类型皆是stringtype T1 string type T2 T1//T3,T4的底层类型皆是[]stringtype T3 []stringtype T4 T3//[]T1 是数组类型即未命名类型，所以T5,T6的底层类型皆是[]T1type T5 []T1type T6 T5 类型隐式转换 &emsp;&emsp;go语言是强类型语言，命名类型可以看作是强类型，未命名类型可以看作是弱类型.很显然，两个强类型相同的变量可直接赋值，而强类型不同则不可转换。因此在两个变量具有相同的底层类型的条件下，还需要其中至少有一个变量是未命名类型才可转换成功。 12345678910111213type Map map[string]stringtype iMap Mapfunc main()&#123; var map1,map2 Map map1=map2 //两个变量强类型相同，可直接赋值 mp := make(map[string]string) mp = map1 //两个 变量底层类型皆是map[string]string，且mp是未命名类型，可转换成功 var imap iMap imap=map1 //两个变量的强类型不同，转换失败&#125; 类型强制转换 在两变量的底层类型相同，但都是强类型时，可使用强制转换，上述代码中：imap 与 map1间可使用强制转换 1imap = iMap(map1) //转换成功","categories":[{"name":"go语言学习笔记","slug":"go语言学习笔记","permalink":"https://hongwuYu.github.io/categories/go语言学习笔记/"}],"tags":[{"name":"go","slug":"go","permalink":"https://hongwuYu.github.io/tags/go/"}]},{"title":"go异常处理机制","slug":"go-third","date":"2019-04-19T12:23:21.000Z","updated":"2019-04-19T15:29:53.000Z","comments":true,"path":"2019/04/19/go-third/","link":"","permalink":"https://hongwuYu.github.io/2019/04/19/go-third/","excerpt":"","text":"defer 考虑如下场景 123456789101112131415161718192021func copyFile(dst,src string)(//go 语言提供有名返回值，可在函数内赋值，return时不必附加返回值w int64,err,error)&#123; src,err := os.Open(src) if err != nil&#123; return &#125; dst,err := os.create(dst) if err != nil&#123; //src很容易被忘记关闭 src.Close() return &#125; //若此时发生异常导致程序中途退出，而仍会导致src，dst的资源泄漏 w,err = io.Copy(dst,src) dst.Close() src.Close() return &#125; 可以看到，我们很难保证资源的正确释放，而defer关键字可以解决这一问题，用defer语句改写的程序如下 123456789101112131415161718func copyFile(dst,src string)(w int64,err,error)&#123; src,err := os.Open(src) if err != nil&#123; return &#125; defer src.Close() dst,err := os.create(dst) if err != nil&#123; return &#125; defer dst.Close() w,err = io.Copy(dst,src) return &#125; &emsp;&emsp;defer 表示为程序注册延迟调用 其后面的语句会在函数调用return，或是因为异常终止后执行，这样以来，无论程序是正常返回还是异常终止，资源都将得到释放，所以也就不会造成资源的泄漏了。可以看到，我们的程序注册了两个延迟调用，这些调用将在函数返回前将以先进后出的顺序执行，defer是以栈的结构来注册延迟调用。&emsp;&emsp;需要注意的是，defer语句也有明显的副作用，它会推迟资源的释放，所以需要程序员合理的使用。 一种特别的情况，程序主动调用os.Exit(int)来退出进程时，defer语句将得不到执行 12345678910111213141516171819package mainimport ( \"os\", \"fmt\",)func main()&#123; //defer 后面可以是方法的调用或是函数，不能是语句 defer func()&#123; fmt.Println(\"defer codeblock\") &#125;() fmt.Println(\"func body\") os.Exit(1) /*输出结果为 * func body * exit status 1 */&#125; panic 与 recover &emsp;&emsp;go语言在出现运行时异常导致程序无法正常时，会自动抛出panic异常来终止程序的运行，亦可由程序员主动调用panic函数。&emsp;&emsp;发生panic后，程序会从调用panic的函数位置或发生panic的地方立即返回，逐层执行注册的defer语句，然后打印出函数的调用堆栈，直到被recover语句捕获或运行到最外层函数退出。 panic的函数签名如下 12/*函数的参数类型为空接口类型，go语言默认所有的数据类型都实现了空接口，所以go语言的空接口的类型类似于c++或是java的范型panic(i interface&#123;&#125;) recover 捕获异常 12345678910111213141516package mainimport ( \"fmt\",)func main()&#123; //revover语句必须放在defer函数体内才能捕获成功，且不能嵌套 defer func()&#123; fmt.Println(\"recover codeblock\") recover() &#125;() panic(\"test panic\") /*输出结果为 * recover codeblock */&#125; 在连续抛出多个panic异常的情况 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\",)func main()&#123; //revover语句必须放在defer函数体内才能捕获成功，且不能嵌套 defer func()&#123; //recover函数返回值为panic参数值 if err := recover(); err != nil&#123; fmt.Println(err) &#125; &#125;() //panic抛出异常则会中断程序，因此只有在defer语句块中才能抛出多个异常 defer func()&#123; panic(\"first panic\") &#125;() defer func()&#123; panic(\"second panic\") &#125;() panic(\"main panic\") /*输出结果为 * first panic */ //结果可知，只有最后一次panic调用才能够被捕获&#125; 注意recover不能捕获其他goroutine抛出的panic error 接口123type error interface&#123; Error() string&#125; 用户可以自定义错误类型，只要其实现error接口即可。go语言异常处理机制可以浓缩为两条法则： 程序发生的错误已经导致程序不能容错继续执行，此时程序应主动调用panic或由运行时抛出panic 程序虽然出错，但仍然能容错执行，此时应该使用错误返回值（即实现的error接口）的方式处理错误，或是在可能抛出panic的位置使用recover来捕获panic","categories":[{"name":"go语言学习笔记","slug":"go语言学习笔记","permalink":"https://hongwuYu.github.io/categories/go语言学习笔记/"}],"tags":[{"name":"go","slug":"go","permalink":"https://hongwuYu.github.io/tags/go/"}]},{"title":"go 数组和切片","slug":"go-second","date":"2019-04-17T06:48:48.000Z","updated":"2019-04-17T10:01:23.000Z","comments":true,"path":"2019/04/17/go-second/","link":"","permalink":"https://hongwuYu.github.io/2019/04/17/go-second/","excerpt":"","text":"go数组 几种定义方式 123var array1 = [5]int&#123;1,2,3,4,5&#125;var array2 = [...]int&#123;1,2,3,4,5&#125; //长度为元素的个数var array3 = [...]int&#123;1:1,5:2&#125; //长度为最大指定的下标+1，且其他未赋值的数组元素自动初始化为0。 数组传参 go语言所有的传参皆是传值调用，指针也只是传指针值（即地址）本质上也是传值。所以单纯的将数组作为参数传参，无法修改数组！ 代码示例 123func testArray(array [5]int) //必须标明数组大小 不同大小的数组对应不同的参数类型。func testArray(array [...]int) //这种写法是不合法的func testArray(array *[5]int) //这种方式可用与在函数内修改数组元素。 &emsp;&emsp;可以看到,go语言的数组用起来有相当大的局限性，一般不常使用，而是使用一种叫切片的技术 go切片 定义方式 123456789var array1 = []int&#123;1,2,3,4,5&#125;var array2 = make([]int,5,10)//通过数组来定义切片var array = [5]int&#123;1,2,3,4,5&#125;var slice1 = array[:] //包含srcArray所有元素var slice2 = array[1:] //包含srcArray下标为1及之后的所有元素var slice3 = array[1:4] // 注意是前闭后开区间var slice4 = array[:4] 切片的底层实现 12345type Slice struct &#123; ptr unsafe.Pointe //指向底层数组的指针 len int //切片的容量 cap int //切片底层数组的容量&#125; 这样即可知 前面用make创建切片时 len=5，cap=10，也可以不指定cap，此时cap=len。并且make会在底层给我们创建一个容量为10的数组。 切片传参 由于切片内部是一个指向数组的指针，因此可以传切片来达到修改数组的目的,并且数组的容量不受限制。 代码示例 123456789101112131415161718192021222324252627package mainimport ( \"fmt\")func main()&#123; var array1 = [...]int&#123;3,4,1,5,2&#125; fmt.Println(array1); //输出[3 4 1 5 2] buddleSort(array1[:]) fmt.Println(array1) //输出[1 2 3 4 5] var array2 = [...]int&#123;3,4,1,5,2,8,6,7&#125; fmt.Println(array2); //输出[3 4 1 5 2 8 6 7] buddleSort(array2[:]) fmt.Println(array2) //输出[1 2 3 4 5 6 7 8]&#125;//一个简单的冒泡排序func buddleSort(array []int)&#123; for i :=0; i &lt; len(array); i++&#123; for j := 0; j&lt;len(array)-i-1; j++&#123; if array[j] &gt; array[j+1]&#123; array[j],array[j+1] = array[j+1],array[j]; &#125; &#125; &#125;&#125; append 与 切片 12345var array = [...]int&#123;1,2,3,4,5,6&#125;var slice = array[1:4] //此时 slice.len=3,slice.cap=5.slice[0] = 3fmt.Println(slice) // 输出为 [1,3,3,4,5,6]slice[4] = 8 //error，越界访问 append基本用法（apend一般用于向切片添加元素） 1234567891011121314151617181920var array = [...]int&#123;1,2,3,4,5,6&#125;var slice = array[1:4]slice = append(slice,8)fmt.Println(array) //输出 [1 2 3 4 8 6]fmt.Println(slice) //输出 [2 3 4 8] fmt.Println(len(slice),cap(slice)) //输出 4，5slice = append(slice,8) fmt.Println(array) //输出 [1 2 3 4 8 8]fmt.Println(slice) //输出 [2 3 4 8 8]fmt.Println(len(slice),cap(slice)) //输出 5，5slice = append(slice,8)/*注意此时array不再变化，而slice可以继续添加元素，因为此时slice指向的底层数组已不再是array。并且cap值翻倍。表示系统在底层重新创建了一个容量为10的数组，并且把之前的数组内容拷贝过来*/fmt.Println(array) //输出 [1 2 3 4 8 8] fmt.Println(slice) //输出 [2 3 4 8 8 8]fmt.Println(len(slice),cap(slice)) 输出 6，10 append 陷阱 123456789101112131415import \"fmt\"func main()&#123; var array = []int&#123;1,2,3,4&#125; slice := array[:] fmt.Println(slice) //输出 [1,2,3,4] testAppend(slice) fmt.Println(slice) //预期输出 [1,2,3,4,5] 实际输出[1,2,3,4] &#125;func testAppend(slice []int)&#123; slice = append(slice,5);&#125; &emsp;&emsp;造成这种差异的原因就是go语言不支持传引用，所谓的切片传参实质只是传底层数组的指针，但是当append检测到底层数组容量不足时，则不会再该指针上操作，而是新开辟一块空间。 在函数中操作切片尽量用返回值！！！","categories":[{"name":"go语言学习笔记","slug":"go语言学习笔记","permalink":"https://hongwuYu.github.io/categories/go语言学习笔记/"}],"tags":[{"name":"go","slug":"go","permalink":"https://hongwuYu.github.io/tags/go/"}]},{"title":"go基础杂项","slug":"go-first","date":"2019-04-16T09:46:03.000Z","updated":"2019-08-24T04:56:20.977Z","comments":true,"path":"2019/04/16/go-first/","link":"","permalink":"https://hongwuYu.github.io/2019/04/16/go-first/","excerpt":"","text":"go语言的string 与其他语言不一样，go语言的string是语言内置类型,其内部存储结构为 1234type stringStruct struct&#123; str unsafe.Pointer //指向底层字节数组的指针 len int //字节数组长度&#125; 并且 go语言的string结尾处没有NULL字符 go语言的标签Label &emsp;&emsp;go语言使用标签（Label）来标识一个语句的位置，用于goto，break,continue语句的跳转，标签的语法是： 12&gt;&gt;&gt;Label:Statement&gt;&gt;&gt; 123456789101112&gt;&gt;&gt;&gt;*goto Label*&gt;&gt;&gt;&gt;&gt;* goto语句只能在函数内跳转&gt;&gt;&gt;* goto语句不能跳过内部声明变量的语句&gt;&gt;*break Label*&gt;&gt;&gt;* 主要用于跳出多重循环，代码示例如下：&gt;&gt;&gt;&gt;&gt; L1: for i := 0; i++{ for j := 0; j++{ if i &gt;= 5{ //跳出L1标签所在的for循环 break L1 } if i &gt;= 10{ //默认仅跳出离break最近的for循环 break } } }123456789&gt;&gt;*continue Label 可类推 break ***byte 与 rune**&gt;&gt;对于字节类型，go语言提供了两种形式：byte与rune. &gt;&gt;*&amp;emsp;&amp;emsp;byte 实质是unit8,以utf-8编码* &gt;&gt;*&amp;emsp;&amp;emsp;rune 实质是unit32,以unicode编码* &gt;&gt;代码示例&gt;&gt;&gt; package main1234567891011121314151617181920import \"fmt\"func main() &#123; s := \"go语言\" bytes := []byte(s) for _,ch := range bytes&#123; // 输出为：goè¯­è¨ 中文乱码，因为一个byte占一个字节，而一个中文字符占两个字节！ fmt.Printf(\"%c\",ch) &#125; fmt.Println(); runes := []rune(s) for _,ch := range runes&#123; //输出为：go语言 一个rune占4个字节，可以正确输出任何字符 fmt.Printf(\"%c\",ch) &#125;&#125; `","categories":[{"name":"go语言学习笔记","slug":"go语言学习笔记","permalink":"https://hongwuYu.github.io/categories/go语言学习笔记/"}],"tags":[{"name":"go","slug":"go","permalink":"https://hongwuYu.github.io/tags/go/"}]}]}