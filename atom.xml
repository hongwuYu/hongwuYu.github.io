<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yhw&#39;s personal blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunyshine.github.io/"/>
  <updated>2019-04-27T15:37:52.000Z</updated>
  <id>https://sunyshine.github.io/</id>
  
  <author>
    <name>hongwu.yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《linux多线程服务端编程》读书笔记-第一章</title>
    <link href="https://sunyshine.github.io/2019/04/27/mudo-first/"/>
    <id>https://sunyshine.github.io/2019/04/27/mudo-first/</id>
    <published>2019-04-27T15:16:48.000Z</published>
    <updated>2019-04-27T15:37:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>构造函数不应暴露this指针</strong>  </li></ul><blockquote><blockquote><p>&emsp;&emsp;对象在构造函数期间尚处于构造中，不是一个完整的对象，若此时暴露this指针，则别的线程可能会访问到这个半成品对象而造成难以预料的后果</p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;构造函数不应暴露this指针&lt;/strong&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;对象在构造函数期间尚处于构造中，不是一个完整的对象，若此时暴露this指针，则别的线程可能
      
    
    </summary>
    
      <category term="《linux多线程服务端编程》读书笔记" scheme="https://sunyshine.github.io/categories/%E3%80%8Alinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://sunyshine.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>go 类型转换</title>
    <link href="https://sunyshine.github.io/2019/04/20/go-forth/"/>
    <id>https://sunyshine.github.io/2019/04/20/go-forth/</id>
    <published>2019-04-20T05:54:47.000Z</published>
    <updated>2019-04-20T06:42:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>go 命名类型与未命名类型</strong>  </p><ul><li>命名类型</li></ul><blockquote><p>go语言提供type关键字来自定义命名类型</p><blockquote><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="built_in">Int</span> <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person struct&#123;</span><br><span class="line">  <span class="keyword">name</span> string</span><br><span class="line">  age <span class="built_in">int</span></span><br><span class="line">&#125;</span><br><span class="line">//<span class="built_in">Int</span> Person 皆是自定义的命名类型</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p>除了自定义命名类型，go语言的20个预声明简单类型（in† float等）皆是命名类型</p></blockquote><ul><li>未命名类型</li></ul><blockquote><p>go语言基本类型中的复合类型：数组，切片，字典，通道，接口等等皆属于未命名类型</p></blockquote><p><strong>底层类型</strong></p><blockquote><p>预声明类型和未命名类型的底层类型是其本身，而自定义类型的底层类型会逐层向下查找，直到查到的类型是预声明类型或是未命名类型为止</p><blockquote><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T1,T2的底层类型皆是string</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">T1</span> <span class="title">string</span>  </span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">T2</span> <span class="title">T1</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//T3,T4的底层类型皆是[]string</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">T3</span> []<span class="title">string</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">T4</span> <span class="title">T3</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[]T1 是数组类型即未命名类型，所以T5,T6的底层类型皆是[]T1</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">T5</span> []<span class="title">T1</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">T6</span> <span class="title">T5</span></span></span><br></pre></td></tr></table></figure></blockquote></blockquote><p><strong>类型隐式转换</strong></p><blockquote><p>&emsp;&emsp;go语言是强类型语言，命名类型可以看作是强类型，未命名类型可以看作是弱类型.很显然，两个强类型相同的变量可直接赋值，而强类型不同则不可转换。因此在两个变量具有相同的底层类型的条件下，还需要其中至少有一个变量是未命名类型才可转换成功。</p></blockquote><blockquote><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> iMap Map</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> map1,map2 Map</span><br><span class="line">map1=map2 <span class="comment">//两个变量强类型相同，可直接赋值</span></span><br><span class="line"></span><br><span class="line">mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">mp = map1 <span class="comment">//两个 变量底层类型皆是map[string]string，且mp是未命名类型，可转换成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> imap iMap</span><br><span class="line">imap=map1 <span class="comment">//两个变量的强类型不同，转换失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><p><strong>类型强制转换</strong></p><blockquote><p>在两变量的底层类型相同，但都是强类型时，可使用强制转换，上述代码中：imap 与 map1间可使用强制转换</p><blockquote><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imap = iMap<span class="comment">(map1)</span> <span class="comment">//转换成功</span></span><br></pre></td></tr></table></figure></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;go 命名类型与未命名类型&lt;/strong&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命名类型&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;go语言提供type关键字来自定义命名类型&lt;/p&gt;
&lt;blockquote&gt;
&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="go语言学习笔记" scheme="https://sunyshine.github.io/categories/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="go" scheme="https://sunyshine.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go异常处理机制</title>
    <link href="https://sunyshine.github.io/2019/04/19/go-third/"/>
    <id>https://sunyshine.github.io/2019/04/19/go-third/</id>
    <published>2019-04-19T12:23:21.000Z</published>
    <updated>2019-04-19T15:29:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>defer</strong></p><p>考虑如下场景</p><blockquote><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func  copyFile(dst,src string)(</span><br><span class="line"><span class="comment">//go 语言提供有名返回值，可在函数内赋值，return时不必附加返回值</span></span><br><span class="line">w int64,<span class="keyword">err</span>,<span class="keyword">error</span>)&#123;</span><br><span class="line">  src,<span class="keyword">err</span> := os.<span class="keyword">Open</span>(src)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">err</span> != nil&#123;</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">  &#125;  </span><br><span class="line">  dst,<span class="keyword">err</span> := os.create(dst)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">err</span> != nil&#123;</span><br><span class="line">    <span class="comment">//src很容易被忘记关闭</span></span><br><span class="line">    src.<span class="keyword">Close</span>()</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//若此时发生异常导致程序中途退出，而仍会导致src，dst的资源泄漏</span></span><br><span class="line">  w,<span class="keyword">err</span> = io.<span class="keyword">Copy</span>(dst,src)</span><br><span class="line">  </span><br><span class="line">  dst.<span class="keyword">Close</span>()</span><br><span class="line">  src.<span class="keyword">Close</span>()</span><br><span class="line">  <span class="built_in">return</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>可以看到，我们很难保证资源的正确释放，而defer关键字可以解决这一问题，用defer语句改写的程序如下</p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">copyFile</span><span class="params">(dst,src <span class="keyword">string</span>)</span><span class="params">(w <span class="keyword">int64</span>,err,error)</span></span>&#123;</span><br><span class="line">  src,err := os.Open(src)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">defer</span> src.Close()</span><br><span class="line">  </span><br><span class="line">  dst,err := os.create(dst)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> dst.Close()</span><br><span class="line">  </span><br><span class="line">  w,err = io.Copy(dst,src)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>&emsp;&emsp;defer 表示为程序注册延迟调用 其后面的语句会在函数调用return，或是因为异常终止后执行，这样以来，无论程序是正常返回还是异常终止，资源都将得到释放，所以也就不会造成资源的泄漏了。可以看到，我们的程序注册了两个延迟调用，这些调用将在函数返回前将以先进后出的顺序执行，defer是以栈的结构来注册延迟调用。<br>&emsp;&emsp;需要注意的是，defer语句也有明显的副作用，它会推迟资源的释放，所以需要程序员合理的使用。</p><ul><li>一种特别的情况，程序主动调用os.Exit(int)来退出进程时，defer语句将得不到执行<blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span>,</span><br><span class="line"><span class="string">"fmt"</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//defer 后面可以是方法的调用或是函数，不能是语句</span></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"defer codeblock"</span>)</span><br><span class="line">  &#125;()</span><br><span class="line">  fmt.Println(<span class="string">"func body"</span>)</span><br><span class="line">  </span><br><span class="line">  os.Exit(<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*输出结果为</span></span><br><span class="line"><span class="comment">  * func body</span></span><br><span class="line"><span class="comment">  * exit status 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p><strong>panic 与 recover</strong></p><blockquote><p>&emsp;&emsp;go语言在出现运行时异常导致程序无法正常时，会自动抛出panic异常来终止程序的运行，亦可由程序员主动调用panic函数。<br>&emsp;&emsp;发生panic后，程序会从调用panic的函数位置或发生panic的地方立即返回，逐层执行注册的defer语句，然后打印出函数的调用堆栈，直到被recover语句捕获或运行到最外层函数退出。</p></blockquote><p>panic的函数签名如下</p><blockquote><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/*函数的参数类型为空接口类型，go语言默认所有的数据类型都实现了空接口，所以go语言的空接口的类型类似于c++或是java的范型</span><br><span class="line">panic(i <span class="class"><span class="keyword">interface</span>&#123;</span>&#125;)</span><br></pre></td></tr></table></figure></blockquote><p>recover 捕获异常</p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//revover语句必须放在defer函数体内才能捕获成功，且不能嵌套</span></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"recover codeblock"</span>)</span><br><span class="line">    <span class="built_in">recover</span>()</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"test panic"</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*输出结果为</span></span><br><span class="line"><span class="comment">  * recover codeblock */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>在连续抛出多个panic异常的情况</p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//revover语句必须放在defer函数体内才能捕获成功，且不能嵌套</span></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//recover函数返回值为panic参数值</span></span><br><span class="line">     <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span>&#123;</span><br><span class="line">       fmt.Println(err)</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="comment">//panic抛出异常则会中断程序，因此只有在defer语句块中才能抛出多个异常</span></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"first panic"</span>)</span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"second panic"</span>)</span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"main panic"</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*输出结果为</span></span><br><span class="line"><span class="comment">  * first panic */</span></span><br><span class="line">  <span class="comment">//结果可知，只有最后一次panic调用才能够被捕获</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li>注意recover不能捕获其他goroutine抛出的panic</li></ul><p><strong>error 接口</strong><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span>&#123;</span><br><span class="line">  <span class="built_in">Error</span>() <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用户可以自定义错误类型，只要其实现error接口即可。<br>go语言异常处理机制可以浓缩为两条法则：</p><ul><li>程序发生的错误已经导致程序不能容错继续执行，此时程序应主动调用panic或由运行时抛出panic</li><li>程序虽然出错，但仍然能容错执行，此时应该使用错误返回值（即实现的error接口）的方式处理错误，或是在可能抛出panic的位置使用recover来捕获panic</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;defer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考虑如下场景&lt;/p&gt;
&lt;blockquote&gt;
&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="go语言学习笔记" scheme="https://sunyshine.github.io/categories/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="go" scheme="https://sunyshine.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go 数组和切片</title>
    <link href="https://sunyshine.github.io/2019/04/17/go-second/"/>
    <id>https://sunyshine.github.io/2019/04/17/go-second/</id>
    <published>2019-04-17T06:48:48.000Z</published>
    <updated>2019-04-17T10:01:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>go数组</strong></p><blockquote><p><em>几种定义方式</em></p><blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> array2 = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; <span class="comment">//长度为元素的个数</span></span><br><span class="line"><span class="keyword">var</span> array3 = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">5</span>:<span class="number">2</span>&#125;   <span class="comment">//长度为最大指定的下标+1，且其他未赋值的数组元素自动初始化为0。</span></span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p><em>数组传参</em></p><blockquote><p>go语言所有的传参皆是传值调用，指针也只是传指针值（即地址）本质上也是传值。所以单纯的将数组作为参数传参，无法修改数组！</p><p>代码示例</p><blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testArray</span><span class="params">(array [<span class="number">5</span>]int)</span></span> <span class="comment">//必须标明数组大小 不同大小的数组对应不同的参数类型。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testArray</span><span class="params">(array [...]int)</span></span> <span class="comment">//这种写法是不合法的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testArray</span><span class="params">(array *[<span class="number">5</span>]int)</span></span>  <span class="comment">//这种方式可用与在函数内修改数组元素。</span></span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote><hr><p>&emsp;&emsp;可以看到,go语言的数组用起来有相当大的局限性，一般不常使用，而是使用一种叫切片的技术</p><hr><p><strong>go切片</strong></p><blockquote><p><em>定义方式</em></p><blockquote><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> array2 = make([]<span class="keyword">int</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过数组来定义切片</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">array</span> = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> slice1 = <span class="keyword">array</span>[:] <span class="comment">//包含srcArray所有元素</span></span><br><span class="line"><span class="keyword">var</span> slice2 = <span class="keyword">array</span>[<span class="number">1</span>:] <span class="comment">//包含srcArray下标为1及之后的所有元素</span></span><br><span class="line"><span class="keyword">var</span> slice3 = <span class="keyword">array</span>[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">// 注意是前闭后开区间</span></span><br><span class="line"><span class="keyword">var</span> slice4 = <span class="keyword">array</span>[:<span class="number">4</span>]</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p><em>切片的底层实现</em></p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice <span class="keyword">struct</span>  &#123;</span><br><span class="line">  ptr unsafe.Pointe <span class="comment">//指向底层数组的指针</span></span><br><span class="line">  <span class="built_in">len</span> <span class="keyword">int</span>           <span class="comment">//切片的容量</span></span><br><span class="line">  <span class="built_in">cap</span> <span class="keyword">int</span>           <span class="comment">//切片底层数组的容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p>这样即可知 前面用make创建切片时 len=5，cap=10，也可以不指定cap，此时cap=len。并且make会在底层给我们创建一个容量为10的数组。</p></blockquote><blockquote><p><em>切片传参</em></p><blockquote><p>由于切片内部是一个指向数组的指针，因此可以传切片来达到修改数组的目的,并且数组的容量不受限制。</p><p> 代码示例</p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> array1 = [...]<span class="keyword">int</span>&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>&#125;</span><br><span class="line">  fmt.Println(array1); <span class="comment">//输出[3 4 1 5 2]</span></span><br><span class="line">  buddleSort(array1[:])</span><br><span class="line">  fmt.Println(array1)  <span class="comment">//输出[1 2 3 4 5]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> array2 = [...]<span class="keyword">int</span>&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">  fmt.Println(array2); <span class="comment">//输出[3 4 1 5 2 8 6 7]</span></span><br><span class="line">  buddleSort(array2[:])</span><br><span class="line">  fmt.Println(array2)  <span class="comment">//输出[1 2 3 4 5 6 7 8]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个简单的冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buddleSort</span><span class="params">(array []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i :=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(array); i++&#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j&lt;<span class="built_in">len</span>(array)-i<span class="number">-1</span>; j++&#123;</span><br><span class="line">      <span class="keyword">if</span> array[j] &gt; array[j+<span class="number">1</span>]&#123;</span><br><span class="line">        array[j],array[j+<span class="number">1</span>] = array[j+<span class="number">1</span>],array[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote><blockquote><p><em>append 与 切片</em></p><blockquote><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var<span class="built_in"> array </span>= [...]int&#123;1,2,3,4,5,6&#125;</span><br><span class="line">var slice = array[1:4] //此时 slice.len=3,slice.cap=5.</span><br><span class="line">slice[0] = 3</span><br><span class="line">fmt.Println(slice) // 输出为 [1,3,3,4,5,6]</span><br><span class="line">slice[4] = 8 //error，越界访问</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p>append基本用法（apend一般用于向切片添加元素）</p><blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var array = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">var slice = array[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">slice = <span class="keyword">append</span>(slice,<span class="number">8</span>)</span><br><span class="line">fmt.<span class="keyword">Println</span>(array)  <span class="comment">//输出 [1 2 3 4 8 6]</span></span><br><span class="line">fmt.<span class="keyword">Println</span>(slice)  <span class="comment">//输出 [2 3 4 8]  </span></span><br><span class="line">fmt.<span class="keyword">Println</span>(len(slice),cap(slice)) <span class="comment">//输出 4，5</span></span><br><span class="line"></span><br><span class="line">slice = <span class="keyword">append</span>(slice,<span class="number">8</span>) </span><br><span class="line">fmt.<span class="keyword">Println</span>(array)  <span class="comment">//输出 [1 2 3 4 8 8]</span></span><br><span class="line">fmt.<span class="keyword">Println</span>(slice)  <span class="comment">//输出 [2 3 4 8 8]</span></span><br><span class="line">fmt.<span class="keyword">Println</span>(len(slice),cap(slice)) <span class="comment">//输出 5，5</span></span><br><span class="line"></span><br><span class="line">slice = <span class="keyword">append</span>(slice,<span class="number">8</span>)</span><br><span class="line"><span class="comment">/*注意此时array不再变化，而slice可以继续添加元素，因为此时</span></span><br><span class="line"><span class="comment">slice指向的底层数组已不再是array。并且cap值翻倍。表示系统在</span></span><br><span class="line"><span class="comment">底层重新创建了一个容量为10的数组，并且把之前的数组内容拷贝过来*/</span></span><br><span class="line">fmt.<span class="keyword">Println</span>(array)  <span class="comment">//输出 [1 2 3 4 8 8] </span></span><br><span class="line">fmt.<span class="keyword">Println</span>(slice)  <span class="comment">//输出 [2 3 4 8 8 8]</span></span><br><span class="line">fmt.<span class="keyword">Println</span>(len(slice),cap(slice)) 输出 <span class="number">6</span>，<span class="number">10</span></span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote><blockquote><blockquote><p>append 陷阱</p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> array = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">  slice := array[:]</span><br><span class="line">  fmt.Println(slice) <span class="comment">//输出 [1,2,3,4]</span></span><br><span class="line">  testAppend(slice)</span><br><span class="line">  fmt.Println(slice) <span class="comment">//预期输出 [1,2,3,4,5] 实际输出[1,2,3,4]</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testAppend</span><span class="params">(slice []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  slice = <span class="built_in">append</span>(slice,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote><blockquote><blockquote><p>&emsp;&emsp;造成这种差异的原因就是go语言不支持传引用，所谓的切片传参实质只是传底层数组的指针，但是当append检测到底层数组容量不足时，则不会再该指针上操作，而是新开辟一块空间。</p><ul><li>在函数中操作切片尽量用返回值！！！</li></ul></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;go数组&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;几种定义方式&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="go语言学习笔记" scheme="https://sunyshine.github.io/categories/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="go" scheme="https://sunyshine.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go基础杂项</title>
    <link href="https://sunyshine.github.io/2019/04/16/go-first/"/>
    <id>https://sunyshine.github.io/2019/04/16/go-first/</id>
    <published>2019-04-16T09:46:03.000Z</published>
    <updated>2019-04-17T06:47:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>go语言的string</strong></p><blockquote><blockquote><p>与其他语言不一样，go语言的string是语言内置类型,其内部存储结构为</p><blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">stringStruct</span></span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="built_in">str</span>  <span class="keyword">unsafe</span>.Pointer  <span class="comment">//指向底层字节数组的指针</span></span><br><span class="line">  len  int             <span class="comment">//字节数组长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><p>并且 go语言的string结尾处没有NULL字符</p></blockquote></blockquote><p><strong>go语言的标签Label</strong></p><blockquote><blockquote><p>&emsp;&emsp;go语言使用标签（Label）来标识一个语句的位置，用于goto，break,continue语句的跳转，标签的语法是：</p><blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Label</span><span class="bash">:Statement</span></span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote><blockquote><blockquote></blockquote></blockquote><blockquote><blockquote><p><em>goto Label</em></p><blockquote><ul><li>goto语句只能在函数内跳转</li></ul></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><ul><li>goto语句不能跳过内部声明变量的语句</li></ul></blockquote></blockquote></blockquote><blockquote><blockquote><p><em>break Label</em></p><blockquote><ul><li>主要用于跳出多重循环，代码示例如下：</li></ul></blockquote><blockquote>   <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">L1:</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i++&#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j++&#123;</span><br><span class="line">      <span class="keyword">if</span> i &gt;= <span class="number">5</span>&#123;</span><br><span class="line">      <span class="regexp">//</span>跳出L1标签所在的<span class="keyword">for</span>循环</span><br><span class="line">        <span class="keyword">break</span> L1</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> i &gt;= <span class="number">10</span>&#123;</span><br><span class="line">        <span class="regexp">//</span>默认仅跳出离<span class="keyword">break</span>最近的<span class="keyword">for</span>循环</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote><blockquote><blockquote><p><em>continue Label 可类推 break </em></p></blockquote></blockquote><p><strong>byte 与 rune</strong></p><blockquote><blockquote><p>对于字节类型，go语言提供了两种形式：byte与rune.<br><em>&emsp;&emsp;byte 实质是unit8,以utf-8编码</em><br><em>&emsp;&emsp;rune 实质是unit32,以unicode编码</em><br>代码示例</p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  s := <span class="string">"go语言"</span></span><br><span class="line">  </span><br><span class="line">  bytes := []<span class="keyword">byte</span>(s)</span><br><span class="line">  <span class="keyword">for</span> _,ch := <span class="keyword">range</span> bytes&#123;</span><br><span class="line">    <span class="comment">// 输出为：goè¯­è¨ 中文乱码，因为一个byte占一个字节，而一个中文字符占两个字节！</span></span><br><span class="line">    fmt.Printf(<span class="string">"%c"</span>,ch)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println();</span><br><span class="line"></span><br><span class="line">  runes := []<span class="keyword">rune</span>(s)</span><br><span class="line">  <span class="keyword">for</span> _,ch := <span class="keyword">range</span> runes&#123;</span><br><span class="line">    <span class="comment">//输出为：go语言 一个rune占4个字节，可以正确输出任何字符</span></span><br><span class="line">    fmt.Printf(<span class="string">"%c"</span>,ch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;go语言的string&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;与其他语言不一样，go语言的string是语言内置类型,其内部存储结构为&lt;/p&gt;
&lt;blockquote&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="go语言学习笔记" scheme="https://sunyshine.github.io/categories/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="go" scheme="https://sunyshine.github.io/tags/go/"/>
    
  </entry>
  
</feed>
